# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else if (layer == 2) {
# For Layer 2, group vertices by their connections to Layer 1
edge_layer1_to_layer2 <- ends(g, E(g)[V(g)$layer == 1], names = FALSE)
connections_to_layer1 <- edge_layer1_to_layer2[edge_layer1_to_layer2[, 2] %in% nodes_in_layer, 1]
# Group Layer 2 nodes by their connections to Layer 1 nodes
layer2_groups <- split(nodes_in_layer, factor(connections_to_layer1, levels = unique(connections_to_layer1)))
y_position_layer1 <- l[V(g)$layer == 1, 2]  # Y positions of Layer 1 nodes
for (i in seq_along(layer2_groups)) {
group_nodes <- layer2_groups[[i]]
if (!is.null(group_nodes)) {
# Assign y positions within the group's layer
l[group_nodes, 2] <- seq(from = y_position_layer1[i] + 0.1, to = y_position_layer1[i] - 0.1, length.out = length(group_nodes))
}
}
} else {
# For Layer 3, adjust y-coordinates to minimize crossings (as per Sugiyama)
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # You can adjust this maximum size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")  # Get the in-degree (number of incoming edges)
# Use the correct method to get the starting vertices of edges
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
if (length(raw_edge_widths) > 0 && max(raw_edge_widths) > 0) {
E(g)$width <- pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths)))
} else {
E(g)$width <- min_edge_width  # Fallback value for edge width if something goes wrong
}
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width,  # Set the vertex border width
rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "in")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else if (layer == 2) {
# For Layer 2, group vertices by their connections to Layer 1
edge_layer1_to_layer2 <- ends(g, E(g)[V(g)$layer == 1], names = FALSE)
connections_to_layer1 <- edge_layer1_to_layer2[edge_layer1_to_layer2[, 2] %in% nodes_in_layer, 1]
# Group Layer 2 nodes by their connections to Layer 1 nodes
layer2_groups <- split(nodes_in_layer, factor(connections_to_layer1, levels = unique(connections_to_layer1)))
y_position_layer1 <- l[V(g)$layer == 1, 2]  # Y positions of Layer 1 nodes
for (i in seq_along(layer2_groups)) {
group_nodes <- layer2_groups[[i]]
if (!is.null(group_nodes)) {
# Assign y positions within the group's layer
l[group_nodes, 2] <- seq(from = y_position_layer1[i] + 0.1, to = y_position_layer1[i] - 0.1, length.out = length(group_nodes))
}
}
} else {
# For Layer 3, adjust y-coordinates to minimize crossings (as per Sugiyama)
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # You can adjust this maximum size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")  # Get the in-degree (number of incoming edges)
# Use the correct method to get the starting vertices of edges
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
if (length(raw_edge_widths) > 0 && max(raw_edge_widths) > 0) {
E(g)$width <- pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths)))
} else {
E(g)$width <- min_edge_width  # Fallback value for edge width if something goes wrong
}
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width,  # Set the vertex border width
rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "total")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else {
# For Layer 2 and Layer 3, preserve the layout determined by Sugiyama
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # You can adjust this maximum size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")  # Get the in-degree (number of incoming edges)
# Use the correct method to get the starting vertices of edges
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
if (length(raw_edge_widths) > 0 && max(raw_edge_widths) > 0) {
E(g)$width <- pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths)))
} else {
E(g)$width <- min_edge_width  # Fallback value for edge width if something goes wrong
}
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width,  # Set the vertex border width
rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with max edge width and vertex border width both set to 2
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "in")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else if (layer == 2) {
# For Layer 2, group vertices by their connections to Layer 1
connections_to_layer1 <- ends(g, E(g)[to(nodes_in_layer)], names = TRUE)[, 1]
# Ensure that the factor levels include all Layer 1 nodes to avoid factor level errors
layer1_nodes <- which(V(g)$layer == 1)
groups <- factor(connections_to_layer1, levels = V(g)$name[layer1_nodes])
# Calculate the mean y-position of each Layer 1 node connected to nodes in Layer 2
positions <- tapply(l[as.numeric(groups), 2], groups, mean)
# Assign y positions to Layer 2 nodes based on their linked Layer 1 node's position
l[nodes_in_layer, 2] <- positions[groups]
} else {
# For Layer 3, adjust y-coordinates to minimize crossings (as per Sugiyama)
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # Adjust size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
E(g)$width <- ifelse(raw_edge_widths > 0, pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths))), min_edge_width)
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width, rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with set parameters
Q
Q
Q
Q
Q
Q
Q
Q
Q
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "total")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else {
# For Layer 2 and Layer 3, preserve the layout determined by Sugiyama
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # You can adjust this maximum size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")  # Get the in-degree (number of incoming edges)
# Use the correct method to get the starting vertices of edges
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
if (length(raw_edge_widths) > 0 && max(raw_edge_widths) > 0) {
E(g)$width <- pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths)))
} else {
E(g)$width <- min_edge_width  # Fallback value for edge width if something goes wrong
}
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width,  # Set the vertex border width
rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with max edge width and vertex border width both set to 2
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "in")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else if (layer == 2) {
# For Layer 2, group vertices by their connections to Layer 1
connections_to_layer1 <- ends(g, E(g)[to(nodes_in_layer)], names = TRUE)[, 1]
# Ensure that the factor levels include all Layer 1 nodes to avoid factor level errors
layer1_nodes <- which(V(g)$layer == 1)
groups <- factor(connections_to_layer1, levels = V(g)$name[layer1_nodes])
# Calculate the mean y-position of each Layer 1 node connected to nodes in Layer 2
positions <- tapply(l[as.numeric(groups), 2], groups, mean)
# Assign y positions to Layer 2 nodes based on their linked Layer 1 node's position
l[nodes_in_layer, 2] <- positions[groups]
} else {
# For Layer 3, adjust y-coordinates to minimize crossings (as per Sugiyama)
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # Adjust size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
E(g)$width <- ifelse(raw_edge_widths > 0, pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths))), min_edge_width)
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width, rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with set parameters
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Handle Layer 1 vertices
nodes_layer1 <- which(V(g)$layer == 1)
citations_count <- degree(g, v = nodes_layer1, mode = "in")
ordered_nodes_layer1 <- nodes_layer1[order(citations_count, decreasing = TRUE)]
l[ordered_nodes_layer1, 2] <- seq(from = 1, to = -1, length.out = length(nodes_layer1))
# Handle Layer 2 vertices
if (any(V(g)$layer == 2)) {
nodes_layer2 <- which(V(g)$layer == 2)
edges_layer1_to_layer2 <- E(g)[from(nodes_layer1) & to(nodes_layer2)]
connections_to_layer1 <- ends(g, edges_layer1_to_layer2, names = TRUE)[, 1]
groups <- factor(connections_to_layer1, levels = V(g)$name[nodes_layer1])
# Calculate average y-position for each group based on connected Layer 1 node
avg_y_positions <- tapply(l[as.integer(groups), 2], groups, mean)
for (group in levels(groups)) {
if (!is.na(group) && !is.null(avg_y_positions[group])) {
group_nodes <- nodes_layer2[groups == group]
l[group_nodes, 2] <- seq(from = avg_y_positions[group] + 0.1, to = avg_y_positions[group] - 0.1, length.out = length(group_nodes))
}
}
}
# Layer 3 positioning remains the same
if (any(V(g)$layer == 3)) {
nodes_layer3 <- which(V(g)$layer == 3)
l[nodes_layer3, 2] <- seq(from = 1, to = -1, length.out = length(nodes_layer3))
}
return(l)
}
# Define colors and set vertex attributes
vertex_colors <- c("red", "green", "blue")
V(g)$color <- vertex_colors[V(g)$layer]
layer_counts <- table(V(g)$layer)
max_size <- 40
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate and normalize edge widths
degree_in <- degree(g, mode = "in")
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)
E(g)$width <- ifelse(raw_edge_widths > 0, pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths))), min_edge_width)
# Plot the graph with custom layout
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width, rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Run the function with the specified parameters
require(visnetwork)
Q
visIgraph(tmp)
require(visnetwork)
require(visNetwork)
visIgraph(tmp)
visIgraph(tmp)  %>%
visEdges(arrows = "from") %>%
visHierarchicalLayout()
dev.off()
dev.off()
dev.off()
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "in")
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
} else if (layer == 2) {
# For Layer 2, group vertices by their connections to Layer 1
edge_layer1_to_layer2 <- E(g)[.from(V(g)$layer == 1) & .to(V(g)$layer == 2)]
connections_to_layer1 <- as.integer(ends(g, edge_layer1_to_layer2, names = FALSE)[, 1])
# Group Layer 2 nodes by their connections to Layer 1 nodes
groups <- factor(connections_to_layer1, levels = V(g)[V(g)$layer == 1]$name)
layer2_groups <- split(nodes_in_layer, groups)
# Retrieve y-positions of Layer 1 nodes
y_position_layer1 <- l[V(g)$layer == 1, 2]
# Assign y positions within each group according to their connected Layer 1 node
for (group in names(layer2_groups)) {
group_nodes <- layer2_groups[[group]]
if (length(group_nodes) > 0) {
index <- which(V(g)$name %in% group)
if (length(index) == 1) {
l[group_nodes, 2] <- seq(from = y_position_layer1[index] + 0.1, to = y_position_layer1[index] - 0.1, length.out = length(group_nodes))
}
}
}
} else {
# For Layer 3, adjust y-coordinates to minimize crossings (as per Sugiyama)
l[nodes_in_layer, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # Adjustable maximum size
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)
E(g)$width <- ifelse(raw_edge_widths > 0, pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths))), min_edge_width)
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width, rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with max edge width and vertex border width both set to 2
plot_tripartite_graph <- function(g, max_edge_width = 1, min_edge_width = 0.01, vertex_border_width = 0.001) {
# Custom layout function similar to the one from StackOverflow
layout_k_partite <- function(g) {
l <- layout_with_sugiyama(g)$layout[, 2:1]  # Perform Sugiyama layout and swap axes
l[, 1] <- V(g)$layer * 200  # Set x-coordinates based on layer
# Sort and evenly space y-coordinates within each layer
for (layer in unique(V(g)$layer)) {
nodes_in_layer <- which(V(g)$layer == layer)
if (layer == 1) {
# Sort Layer 1 vertices by the number of first-degree citations (incoming edges from Layer 2)
citations_count <- degree(g, v = nodes_in_layer, mode = "total")
} else if (layer == 2) {
# Sort Layer 2 vertices by the number of second-degree citations (incoming edges from Layer 3)
citations_count <- degree(g, v = nodes_in_layer, mode = "total")
} else {
# For Layer 3, order normally (or use Sugiyama to minimize crossings)
citations_count <- degree(g, v = nodes_in_layer, mode = "total")
}
# Order nodes by descending citation count
ordered_nodes <- nodes_in_layer[order(citations_count, decreasing = TRUE)]
# Space out nodes vertically in the ordered sequence
l[ordered_nodes, 2] <- seq(from = 1, to = -1, length.out = length(nodes_in_layer))
}
return(l)
}
# Define colors for each layer
vertex_colors <- c("red", "green", "blue")
# Set vertex colors based on the layer attribute
V(g)$color <- vertex_colors[V(g)$layer]
# Calculate vertex sizes inversely proportional to the number of vertices in each layer
layer_counts <- table(V(g)$layer)
max_size <- 40  # You can adjust this maximum size as needed
V(g)$size <- max_size / sqrt(layer_counts[V(g)$layer])
# Calculate edge widths inversely proportional to the number of incoming edges for each vertex
degree_in <- degree(g, mode = "in")  # Get the in-degree (number of incoming edges)
# Use the correct method to get the starting vertices of edges
edge_from <- ends(g, E(g), names = FALSE)[, 1]
raw_edge_widths <- 1 / (degree_in[edge_from] + 1)  # Avoid division by zero
# Normalize edge widths and enforce minimum edge width
if (length(raw_edge_widths) > 0 && max(raw_edge_widths) > 0) {
E(g)$width <- pmax(min_edge_width, max_edge_width * (raw_edge_widths / max(raw_edge_widths)))
} else {
E(g)$width <- min_edge_width  # Fallback value for edge width if something goes wrong
}
# Plot the graph using the custom layout without text labels
plot(g, layout = layout_k_partite(g), vertex.size = V(g)$size, vertex.label = NA,
vertex.color = V(g)$color, edge.width = E(g)$width, edge.arrow.size = 0.2, edge.curved = 0.1,
vertex.frame.width = vertex_border_width,  # Set the vertex border width
rescale = TRUE, asp = 0)
}
plot_tripartite_graph(tmp)  # Example with max edge width and vertex border width both set to 2
https://threadreaderapp.com/thread/1819085303795372413
https://threadreaderapp.com/thread/1819085303795372413
library(V8)
library(jsonlite)
ct = v8()
ct$source("_data/map.txt")
#Transfer the JavaScript variable citation into R by the get() method.
citation = ct$get("citation")
results = citation$results[, 1:4]
head(results)
#convert to proper json
json.out<-toJSON(results)
#print(names(json.out))
write(json.out, file='_data/map_data.json')
tb = data.frame(address = tapply(results$address, results$address, function(x) x[1]),
publicationCount = tapply(results$publicationCount, results$address, sum),
lat = tapply(results$lat, results$address, mean),
lon = tapply(results$lon, results$address, mean))
#convert to proper json (if merging at the city level)
json.out<-toJSON(tb)
write(json.out, file='_data/map_data.json')
